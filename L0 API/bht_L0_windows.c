/************************************************************************
*  File: pci9056_diag.c
*
*  Sample user-mode diagnostics application for accessing PCI9056
*  devices using WinDriver's API.
*  Code was generated by DriverWizard v10.20.
*
*  Jungo Confidential. Copyright (c) 2017 Jungo Ltd.  http://www.jungo.com
*************************************************************************/

#include <stdio.h>
#include <wdc_defs.h>
#include <wdc_lib.h>
#include <utils.h>
#include <status_strings.h>
#include <samples/shared/diag_lib.h>
#include <samples/shared/wdc_diag_lib.h>
#include <samples/shared/pci_regs.h>
#include <pci9056_lib.h>

/*************************************************************
  General definitions
 *************************************************************/
/* Error messages display */
#define PCI9056_ERR printf

/*************************************************************
  Global variables
 *************************************************************/
/* User's input command */
static CHAR gsInput[256];

/* --------------------------------------------------
    PCI9056 configuration registers information
   -------------------------------------------------- */
/* Configuration registers information array */
const WDC_REG gPCI9056_CfgRegs[] = {
    { WDC_AD_CFG_SPACE, PCI_VID, WDC_SIZE_16, WDC_READ_WRITE, "VID", "Vendor ID" },
    { WDC_AD_CFG_SPACE, PCI_DID, WDC_SIZE_16, WDC_READ_WRITE, "DID", "Device ID" },
    { WDC_AD_CFG_SPACE, PCI_CR, WDC_SIZE_16, WDC_READ_WRITE, "CMD", "Command" },
    { WDC_AD_CFG_SPACE, PCI_SR, WDC_SIZE_16, WDC_READ_WRITE, "STS", "Status" },
    { WDC_AD_CFG_SPACE, PCI_REV, WDC_SIZE_32, WDC_READ_WRITE, "RID_CLCD", "Revision ID & Class Code" },
    { WDC_AD_CFG_SPACE, PCI_CCSC, WDC_SIZE_8, WDC_READ_WRITE, "SCC", "Sub Class Code" },
    { WDC_AD_CFG_SPACE, PCI_CCBC, WDC_SIZE_8, WDC_READ_WRITE, "BCC", "Base Class Code" },
    { WDC_AD_CFG_SPACE, PCI_CLSR, WDC_SIZE_8, WDC_READ_WRITE, "CALN", "Cache Line Size" },
    { WDC_AD_CFG_SPACE, PCI_LTR, WDC_SIZE_8, WDC_READ_WRITE, "LAT", "Latency Timer" },
    { WDC_AD_CFG_SPACE, PCI_HDR, WDC_SIZE_8, WDC_READ_WRITE, "HDR", "Header Type" },
    { WDC_AD_CFG_SPACE, PCI_BISTR, WDC_SIZE_8, WDC_READ_WRITE, "BIST", "Built-in Self Test" },
    { WDC_AD_CFG_SPACE, PCI_BAR0, WDC_SIZE_32, WDC_READ_WRITE, "BADDR0", "Base Address 0" },
    { WDC_AD_CFG_SPACE, PCI_BAR1, WDC_SIZE_32, WDC_READ_WRITE, "BADDR1", "Base Address 1" },
    { WDC_AD_CFG_SPACE, PCI_BAR2, WDC_SIZE_32, WDC_READ_WRITE, "BADDR2", "Base Address 2" },
    { WDC_AD_CFG_SPACE, PCI_BAR3, WDC_SIZE_32, WDC_READ_WRITE, "BADDR3", "Base Address 3" },
    { WDC_AD_CFG_SPACE, PCI_BAR4, WDC_SIZE_32, WDC_READ_WRITE, "BADDR4", "Base Address 4" },
    { WDC_AD_CFG_SPACE, PCI_BAR5, WDC_SIZE_32, WDC_READ_WRITE, "BADDR5", "Base Address 5" },
    { WDC_AD_CFG_SPACE, PCI_CIS, WDC_SIZE_32, WDC_READ_WRITE, "CIS", "CardBus CIS Pointer" },
    { WDC_AD_CFG_SPACE, PCI_SVID, WDC_SIZE_16, WDC_READ_WRITE, "SVID", "Sub-system Vendor ID" },
    { WDC_AD_CFG_SPACE, PCI_SDID, WDC_SIZE_16, WDC_READ_WRITE, "SDID", "Sub-system Device ID" },
    { WDC_AD_CFG_SPACE, PCI_EROM, WDC_SIZE_32, WDC_READ_WRITE, "EROM", "Expansion ROM Base Address" },
    { WDC_AD_CFG_SPACE, PCI_CAP, WDC_SIZE_8, WDC_READ_WRITE, "NEW_CAP", "New Capabilities Pointer" },
    { WDC_AD_CFG_SPACE, PCI_ILR, WDC_SIZE_32, WDC_READ_WRITE, "INTLN", "Interrupt Line" },
    { WDC_AD_CFG_SPACE, PCI_IPR, WDC_SIZE_32, WDC_READ_WRITE, "INTPIN", "Interrupt Pin" },
    { WDC_AD_CFG_SPACE, PCI_MGR, WDC_SIZE_32, WDC_READ_WRITE, "MINGNT", "Minimum Required Burst Period" },
    { WDC_AD_CFG_SPACE, PCI_MLR, WDC_SIZE_32, WDC_READ_WRITE, "MAXLAT", "Maximum Latency" },
    };
#define PCI9056_CFG_REGS_NUM sizeof(gPCI9056_CfgRegs) / sizeof(WDC_REG)
/* TODO: For read-only or write-only registers, change the direction field of
         the relevant registers in gPCI9056_CfgRegs to WDC_READ or WDC_WRITE. */
/* NOTE: You can define additional configuration registers in gPCI9056_CfgRegs. */
const WDC_REG *gpPCI9056_CfgRegs = gPCI9056_CfgRegs;

/* -----------------------------------------------
    PCI9056 run-time registers information
   ----------------------------------------------- */
/* Run-time registers information array */
/* const WDC_REG gPCI9056_Regs[]; */
const WDC_REG *gpPCI9056_Regs = NULL;

UINT32 int_count = 0;
/* TODO: You can remove the comment from the gPCI9056_Regs array declaration and
         fill the array with run-time registers information for your device,
         in which case be sure to set gpPCI9056_Regs to point to gPCI9056_Regs. */
#define PCI9056_REGS_NUM 0

/*************************************************************
  Static functions prototypes
 *************************************************************/
/* -----------------------------------------------
    Main diagnostics menu
   ----------------------------------------------- */
static void MenuMain(WDC_DEVICE_HANDLE *phDev);

/* -----------------------------------------------
    Device find, open and close
   ----------------------------------------------- */
static WDC_DEVICE_HANDLE DeviceFindAndOpen(DWORD dwVendorId, DWORD dwDeviceId);
static BOOL DeviceFind(DWORD dwVendorId, DWORD dwDeviceId, WD_PCI_SLOT *pSlot);
static WDC_DEVICE_HANDLE DeviceOpen(const WD_PCI_SLOT *pSlot);
static void DeviceClose(WDC_DEVICE_HANDLE hDev);

/* -----------------------------------------------
    Read/write memory and I/O addresses
   ----------------------------------------------- */
static void MenuReadWriteAddr(WDC_DEVICE_HANDLE hDev);
static void SetAddrSpace(WDC_DEVICE_HANDLE hDev, PDWORD pdwAddrSpace);

/* -----------------------------------------------
    Read/write the configuration space
   ----------------------------------------------- */
static void MenuReadWriteCfgSpace(WDC_DEVICE_HANDLE hDev);

/* -----------------------------------------------
    Read/write the run-time registers
   ----------------------------------------------- */
static void MenuReadWriteRegs(WDC_DEVICE_HANDLE hDev);

/* -----------------------------------------------
    Interrupt handling
   ----------------------------------------------- */
static void MenuInterrupts(WDC_DEVICE_HANDLE hDev);
static void DiagIntHandler(WDC_DEVICE_HANDLE hDev, PCI9056_INT_RESULT *pIntResult);

/* ----------------------------------------------------
    Plug-and-play and power management events handling
   ---------------------------------------------------- */
static void MenuEvents(WDC_DEVICE_HANDLE hDev);
static void DiagEventHandler(WDC_DEVICE_HANDLE hDev, DWORD dwAction);

/*************************************************************
  Functions implementation
 *************************************************************/
 #if 0
int main(void)
{
    WDC_DEVICE_HANDLE hDev = NULL;
    DWORD dwStatus;

    printf("\n");
    printf("PCI9056 diagnostic utility.\n");
    printf("Application accesses hardware using " WD_PROD_NAME ".\n");

    /* Initialize the PCI9056 library */
    dwStatus = PCI9056_LibInit();
    if (WD_STATUS_SUCCESS != dwStatus)
    {
        PCI9056_ERR("pci9056_diag: Failed to initialize the PCI9056 library: %s",
            PCI9056_GetLastErr());
        return dwStatus;
    }

    /* Find and open a PCI9056 device (by default ID) */
    if (PCI9056_DEFAULT_VENDOR_ID)
        hDev = DeviceFindAndOpen(PCI9056_DEFAULT_VENDOR_ID, PCI9056_DEFAULT_DEVICE_ID);

    /* Display main diagnostics menu for communicating with the device */
#if 0
    MenuMain(&hDev);
#else
    do
    {
        UINT32 u32Data = 0;
        
        //enable 9056 interrupt
        u32Data = BIT8 | BIT11 | BIT16 | BIT18 | BIT19;
        dwStatus = WDC_WriteAddr32(hDev, 0, 0x68, u32Data);
        if(WD_STATUS_SUCCESS != dwStatus)
            PCI9056_ERR("pci9056_diag: Failed to enable 9056 interrupt\n");

        //enable 429 pci interrupt
        u32Data = BIT0;
        dwStatus = WDC_WriteAddr32(hDev, 2, 0x30, u32Data);
        if(WD_STATUS_SUCCESS != dwStatus)
            PCI9056_ERR("pci9056_diag: Failed to enable 429 interrupt\n");

        //enable windriver device interrupt
        dwStatus = PCI9056_IntEnable(hDev, DiagIntHandler);
        if(WD_STATUS_SUCCESS != dwStatus)
            PCI9056_ERR("pci9056_diag: Failed to enable 9056 interrupt\n");

		printf("enable windriver interrupt\n");
		Sleep(2000);
        printf("enable windriver interrupt 2 second later\n");

        //429 set pci interrupt
//        u32Data = BIT0;
//        dwStatus = WDC_WriteAddr32(hDev, 2, 0x20, u32Data);
//        if(WD_STATUS_SUCCESS != dwStatus)
//            PCI9056_ERR("pci9056_diag: Failed to set 429 pci interrupt\n");

        WDC_WriteAddr32(hDev, 2, 0x1000, BIT0);
		WDC_WriteAddr32(hDev, 2, 0x1004, 16);
		WDC_WriteAddr32(hDev, 2, 0x1008, 0x6001a000);
		WDC_WriteAddr32(hDev, 2, 0x100c, 0x1f40);
		WDC_WriteAddr32(hDev, 2, 0x1010, 0);
		WDC_WriteAddr32(hDev, 2, 0x1000, 0);
        
        //wait interrupt
        while(1)
        {
            WDC_Sleep(10, WDC_SLEEP_BUSY);
            if(int_count)
                break;
        };
    }while(0);
#endif

    /* Perform necessary cleanup before exiting the program */
    if (hDev)
        DeviceClose(hDev);
 
    dwStatus = PCI9056_LibUninit();
    if (WD_STATUS_SUCCESS != dwStatus)
        PCI9056_ERR("pci9056_diag: Failed to uninit the PCI9056 library: %s", PCI9056_GetLastErr());
    
    return dwStatus;
}
#endif
/* -----------------------------------------------
    Main diagnostics menu
   ----------------------------------------------- */
/* Main menu options */
enum {
    MENU_MAIN_SCAN_PCI_BUS = 1,
    MENU_MAIN_FIND_AND_OPEN,
    MENU_MAIN_RW_ADDR,
    MENU_MAIN_RW_CFG_SPACE,
    MENU_MAIN_RW_REGS,
    MENU_MAIN_ENABLE_DISABLE_INT,
    MENU_MAIN_EVENTS,
    MENU_MAIN_EXIT = DIAG_EXIT_MENU,
};
#if 0
/* Main diagnostics menu */
static void MenuMain(WDC_DEVICE_HANDLE *phDev)
{
    DWORD option;
    
    do
    {
        printf("\n");
        printf("PCI9056 main menu\n");
        printf("--------------\n");
        printf("%d. Scan PCI bus\n", MENU_MAIN_SCAN_PCI_BUS);
        printf("%d. Find and open a PCI9056 device\n", MENU_MAIN_FIND_AND_OPEN);
        if (*phDev)
        {
            printf("%d. Read/write memory and IO addresses on the device\n",
                MENU_MAIN_RW_ADDR);
            printf("%d. Read/write the device's configuration space\n",
                MENU_MAIN_RW_CFG_SPACE);
            if (PCI9056_REGS_NUM)
            {
                printf("%d. Read/write the run-time registers\n",
                    MENU_MAIN_RW_REGS);
            }
            printf("%d. Enable/disable the device's interrupts\n",
                MENU_MAIN_ENABLE_DISABLE_INT);
            printf("%d. Register/unregister plug-and-play and power management "
                "events\n", MENU_MAIN_EVENTS);
        }
        printf("%d. Exit\n", MENU_MAIN_EXIT);
        
        if (DIAG_INPUT_FAIL == DIAG_GetMenuOption(&option,
            *phDev ? MENU_MAIN_EVENTS : MENU_MAIN_FIND_AND_OPEN))
        {
            continue;
        }

        switch (option)
        {
        case MENU_MAIN_EXIT: /* Exit menu */
            break;
        case MENU_MAIN_SCAN_PCI_BUS: /* Scan PCI bus */
            WDC_DIAG_PciDevicesInfoPrintAll(FALSE);
            break;
        case MENU_MAIN_FIND_AND_OPEN: /* Find and open a PCI9056 device */
            if (*phDev)
                DeviceClose(*phDev);
            *phDev = DeviceFindAndOpen(0, 0);
            break;
        case MENU_MAIN_RW_ADDR: /* Read/write memory and I/O addresses */
            MenuReadWriteAddr(*phDev);
            break;
        case MENU_MAIN_RW_CFG_SPACE: /* Read/Write the PCI9056 configuration space */
            MenuReadWriteCfgSpace(*phDev);
            break;
        case MENU_MAIN_RW_REGS: /* Read/write the run-time registers */
            if (PCI9056_REGS_NUM)
                MenuReadWriteRegs(*phDev);
            else
                printf("Invalid selection\n");
            break;
        case MENU_MAIN_ENABLE_DISABLE_INT: /* Enable/disable interrupts */
            MenuInterrupts(*phDev);
            break;
        case MENU_MAIN_EVENTS: /* Register/unregister plug-and-play and power management events */
            MenuEvents(*phDev);
            break;
        }
    } while (MENU_MAIN_EXIT != option);
}
#endif
/* -----------------------------------------------
    Device find, open and close
   ----------------------------------------------- */
/* Find and open a PCI9056 device */
static WDC_DEVICE_HANDLE DeviceFindAndOpen(DWORD dwVendorId, DWORD dwDeviceId)
{
    WD_PCI_SLOT slot;
    
    if (!DeviceFind(dwVendorId, dwDeviceId, &slot))
        return NULL;

    return DeviceOpen(&slot);
}

/* Find a PCI9056 device */
static BOOL DeviceFind(DWORD dwVendorId, DWORD dwDeviceId, WD_PCI_SLOT *pSlot)
{
    DWORD dwStatus;
    DWORD i, dwNumDevices;
    WDC_PCI_SCAN_RESULT scanResult;

    if (dwVendorId == 0)
    {
        if (DIAG_INPUT_SUCCESS != DIAG_InputDWORD((PVOID)&dwVendorId,
            "Enter vendor ID", TRUE, 0, 0))
        {
            return FALSE;
        }

        if (DIAG_INPUT_SUCCESS != DIAG_InputDWORD((PVOID)&dwDeviceId,
            "Enter device ID", TRUE, 0, 0))
        {
            return FALSE;
        }
    }

    BZERO(scanResult);
    dwStatus = WDC_PciScanDevices(dwVendorId, dwDeviceId, &scanResult);
    if (WD_STATUS_SUCCESS != dwStatus)
    {
        PCI9056_ERR("DeviceFind: Failed scanning the PCI bus.\n"
            "Error: 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
        return FALSE;
    }

    dwNumDevices = scanResult.dwNumDevices;
    if (!dwNumDevices)
    {
        PCI9056_ERR("No matching device was found for search criteria "
            "(Vendor ID 0x%lX, Device ID 0x%lX)\n",
            dwVendorId, dwDeviceId);

        return FALSE;
    }
    
    printf("\n");
    printf("Found %ld matching device%s [ Vendor ID 0x%lX%s, Device ID 0x%lX%s ]:\n",
        dwNumDevices, dwNumDevices > 1 ? "s" : "",
        dwVendorId, dwVendorId ? "" : " (ALL)",
        dwDeviceId, dwDeviceId ? "" : " (ALL)");
    
    for (i = 0; i < dwNumDevices; i++)
    {
        printf("\n");
        printf("%2ld. Vendor ID: 0x%lX, Device ID: 0x%lX\n",
            i + 1,
            scanResult.deviceId[i].dwVendorId,
            scanResult.deviceId[i].dwDeviceId);

        WDC_DIAG_PciDeviceInfoPrint(&scanResult.deviceSlot[i], FALSE);
    }
    printf("\n");

    if (dwNumDevices > 1)
    {
        sprintf(gsInput, "Select a device (1 - %ld): ", dwNumDevices);
        i = 0;
        if (DIAG_INPUT_SUCCESS != DIAG_InputDWORD((PVOID)&i,
            gsInput, FALSE, 1, dwNumDevices))
        {
            return FALSE;
        }
    }

    *pSlot = scanResult.deviceSlot[i - 1];

    return TRUE;
}

/* Open a handle to a PCI9056 device */
static WDC_DEVICE_HANDLE DeviceOpen(const WD_PCI_SLOT *pSlot)
{
    WDC_DEVICE_HANDLE hDev;
    DWORD dwStatus;
    WD_PCI_CARD_INFO deviceInfo;
    
    /* Retrieve the device's resources information */
    BZERO(deviceInfo);
    deviceInfo.pciSlot = *pSlot;
    dwStatus = WDC_PciGetDeviceInfo(&deviceInfo);
    if (WD_STATUS_SUCCESS != dwStatus)
    {
        PCI9056_ERR("DeviceOpen: Failed retrieving the device's resources information.\n"
            "Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
        return NULL;
    }

    /* NOTE: You can modify the device's resources information here, if
       necessary (mainly the deviceInfo.Card.Items array or the items number -
       deviceInfo.Card.dwItems) in order to register only some of the resources
       or register only a portion of a specific address space, for example. */

    /* Open a handle to the device */
    hDev = PCI9056_DeviceOpen(&deviceInfo);
    if (!hDev)
    {
        PCI9056_ERR("DeviceOpen: Failed opening a handle to the device: %s",
            PCI9056_GetLastErr());
        return NULL;
    }

    return hDev;
}

/* Close handle to a PCI9056 device */
static void DeviceClose(WDC_DEVICE_HANDLE hDev)
{
    if (!hDev)
        return;

    if (!PCI9056_DeviceClose(hDev))
    {
        PCI9056_ERR("DeviceClose: Failed closing PCI9056 device: %s",
            PCI9056_GetLastErr());
    }
}

/* -----------------------------------------------
    Read/write memory and I/O addresses
   ----------------------------------------------- */
/* Read/write address menu options */
enum {
    MENU_RW_ADDR_SET_ADDR_SPACE = 1,
    MENU_RW_ADDR_SET_MODE,
    MENU_RW_ADDR_SET_TRANS_TYPE,
    MENU_RW_ADDR_READ,
    MENU_RW_ADDR_WRITE,
    MENU_RW_ADDR_EXIT = DIAG_EXIT_MENU,
};

#define ACTIVE_ADDR_SPACE_NEEDS_INIT 0xFF

/* Read/write memory or I/O space address menu */
static void MenuReadWriteAddr(WDC_DEVICE_HANDLE hDev)
{
    DWORD option;
    static DWORD dwAddrSpace = ACTIVE_ADDR_SPACE_NEEDS_INIT;
    static WDC_ADDR_MODE mode = WDC_MODE_32;
    static BOOL fBlock = FALSE;

    /* Initialize active address space */
    if (ACTIVE_ADDR_SPACE_NEEDS_INIT == dwAddrSpace)
    {
        DWORD dwNumAddrSpaces = PCI9056_GetNumAddrSpaces(hDev);
        
        /* Find the first active address space */
        for (dwAddrSpace = 0; dwAddrSpace < dwNumAddrSpaces; dwAddrSpace++)
        {
            if (WDC_AddrSpaceIsActive(hDev, dwAddrSpace))
                break;
        }
        
        /* Sanity check */
        if (dwAddrSpace == dwNumAddrSpaces)
        {
            PCI9056_ERR("MenuReadWriteAddr: Error - no active address spaces found\n");
            dwAddrSpace = ACTIVE_ADDR_SPACE_NEEDS_INIT;
            return;
        }
    }

    do
    {
        printf("\n");
        printf("Read/write the device's memory and IO ranges\n");
        printf("---------------------------------------------\n");
        printf("%d. Change active address space for read/write "
            "(currently: BAR %ld)\n", MENU_RW_ADDR_SET_ADDR_SPACE, dwAddrSpace);
        printf("%d. Change active read/write mode (currently: %s)\n",
            MENU_RW_ADDR_SET_MODE,
            (WDC_MODE_8 == mode) ? "8 bit" : (WDC_MODE_16 == mode) ? "16 bit" :
            (WDC_MODE_32 == mode) ? "32 bit" : "64 bit");
        printf("%d. Toggle active transfer type (currently: %s)\n",
            MENU_RW_ADDR_SET_TRANS_TYPE,
            (fBlock ? "block transfers" : "non-block transfers"));
        printf("%d. Read from active address space\n", MENU_RW_ADDR_READ);
        printf("%d. Write to active address space\n", MENU_RW_ADDR_WRITE);
        printf("%d. Exit menu\n", MENU_RW_ADDR_EXIT);
        printf("\n");
        
        if (DIAG_INPUT_FAIL == DIAG_GetMenuOption(&option,
            MENU_RW_ADDR_WRITE))
        {
            continue;
        }
        
        switch (option)
        {
        case MENU_RW_ADDR_EXIT: /* Exit menu */
            break;
        case MENU_RW_ADDR_SET_ADDR_SPACE: /* Set active address space for read/write address requests */
        {
            SetAddrSpace(hDev, &dwAddrSpace);
            break;
        }
        case MENU_RW_ADDR_SET_MODE: /* Set active mode for read/write address requests */
            WDC_DIAG_SetMode(&mode);
            break;
        case MENU_RW_ADDR_SET_TRANS_TYPE: /* Toggle active transfer type */
            fBlock = !fBlock;
            break;
        case MENU_RW_ADDR_READ:  /* Read from a memory or I/O address */
        case MENU_RW_ADDR_WRITE: /* Write to a memory or I/O address */
        {
            WDC_DIRECTION direction =
                (MENU_RW_ADDR_READ == option) ? WDC_READ : WDC_WRITE;

            if (fBlock)
                WDC_DIAG_ReadWriteBlock(hDev, direction, dwAddrSpace);
            else
                WDC_DIAG_ReadWriteAddr(hDev, direction, dwAddrSpace, mode);
            
            break;
        }
        }
    } while (MENU_RW_ADDR_EXIT != option);
}

static void SetAddrSpace(WDC_DEVICE_HANDLE hDev, PDWORD pdwAddrSpace)
{
    DWORD dwAddrSpace;
    DWORD dwNumAddrSpaces = PCI9056_GetNumAddrSpaces(hDev);
    PCI9056_ADDR_SPACE_INFO addrSpaceInfo;
    
    printf("\n");
    printf("Select an active address space:\n");
    printf("-------------------------------\n");

    for (dwAddrSpace = 0; dwAddrSpace < dwNumAddrSpaces; dwAddrSpace++)
    {
        BZERO(addrSpaceInfo);
        addrSpaceInfo.dwAddrSpace = dwAddrSpace;
        if (!PCI9056_GetAddrSpaceInfo(hDev, &addrSpaceInfo))
        {
            PCI9056_ERR("SetAddrSpace: Error - Failed to get address space information: %s",
                PCI9056_GetLastErr());
            return;
        }

        printf("%ld. %-*s %-*s %s\n",
            dwAddrSpace + 1,
            MAX_NAME_DISPLAY, addrSpaceInfo.sName,
            MAX_TYPE - 1, addrSpaceInfo.sType,
            addrSpaceInfo.sDesc);
    }
    printf("\n");

    if (DIAG_INPUT_SUCCESS != DIAG_InputDWORD((PVOID)&dwAddrSpace,
        "Enter option", FALSE, 1, dwNumAddrSpaces))
    {
         return;
    }

    dwAddrSpace--;
    if (!WDC_AddrSpaceIsActive(hDev, dwAddrSpace))
    {
        printf("You have selected an inactive address space\n");
        return;
    }
            
    *pdwAddrSpace = dwAddrSpace;
}

/* -----------------------------------------------
    Read/write the configuration space
   ----------------------------------------------- */
/* Read/write the configuration space menu options */
enum {
    MENU_RW_CFG_SPACE_READ_OFFSET = 1,
    MENU_RW_CFG_SPACE_WRITE_OFFSET,
    MENU_RW_CFG_SPACE_READ_ALL_REGS,
    MENU_RW_CFG_SPACE_READ_REG,
    MENU_RW_CFG_SPACE_WRITE_REG,
    MENU_RW_CFG_SPACE_EXIT = DIAG_EXIT_MENU,
};

/* Display read/write configuration space menu */
static void MenuReadWriteCfgSpace(WDC_DEVICE_HANDLE hDev)
{
    DWORD option;
  
    do {
        /* Display pre-defined registers' information */
        if (PCI9056_CFG_REGS_NUM)
        {
            printf("\n");
            printf("Configuration registers:\n");
            printf("------------------------\n");
            WDC_DIAG_RegsInfoPrint(gpPCI9056_CfgRegs, PCI9056_CFG_REGS_NUM,
                WDC_DIAG_REG_PRINT_ALL & ~WDC_DIAG_REG_PRINT_ADDR_SPACE);
        }

        printf("\n");
        printf("Read/write the device's configuration space\n");
        printf("--------------------------------------------\n");
        printf("%d. Read from an offset\n", MENU_RW_CFG_SPACE_READ_OFFSET);
        printf("%d. Write to an offset\n", MENU_RW_CFG_SPACE_WRITE_OFFSET);
        if (PCI9056_CFG_REGS_NUM)
        {
            printf("%d. Read all configuration registers defined for the device (see list above)\n",
                MENU_RW_CFG_SPACE_READ_ALL_REGS);
            printf("%d. Read from a named register\n", MENU_RW_CFG_SPACE_READ_REG);
            printf("%d. Write to a named register\n", MENU_RW_CFG_SPACE_WRITE_REG);
        }
        printf("%d. Exit menu\n", MENU_RW_CFG_SPACE_EXIT);
        printf("\n");

        if (DIAG_INPUT_FAIL == DIAG_GetMenuOption(&option,
            PCI9056_CFG_REGS_NUM ? MENU_RW_CFG_SPACE_WRITE_REG :
            MENU_RW_CFG_SPACE_WRITE_OFFSET))
        {
            continue;
        }
        
        switch (option)
        {
        case MENU_RW_CFG_SPACE_EXIT: /* Exit menu */
            break;
        case MENU_RW_CFG_SPACE_READ_OFFSET: /* Read from a configuration space offset */
            WDC_DIAG_ReadWriteBlock(hDev, WDC_READ, WDC_AD_CFG_SPACE);
            break;
        case MENU_RW_CFG_SPACE_WRITE_OFFSET: /* Write to a configuration space offset */
            WDC_DIAG_ReadWriteBlock(hDev, WDC_WRITE, WDC_AD_CFG_SPACE);
            break;
        case MENU_RW_CFG_SPACE_READ_ALL_REGS:
            WDC_DIAG_ReadRegsAll(hDev, gpPCI9056_CfgRegs, PCI9056_CFG_REGS_NUM, TRUE);
            break;
        case MENU_RW_CFG_SPACE_READ_REG:  /* Read from a configuration register */
            WDC_DIAG_ReadWriteReg(hDev, gpPCI9056_CfgRegs, PCI9056_CFG_REGS_NUM, WDC_READ, TRUE);
            break;
        case MENU_RW_CFG_SPACE_WRITE_REG: /* Write to a configuration register */
            WDC_DIAG_ReadWriteReg(hDev, gpPCI9056_CfgRegs, PCI9056_CFG_REGS_NUM, WDC_WRITE, TRUE);
            break;
        }
    } while (MENU_RW_CFG_SPACE_EXIT != option);
}

/* -----------------------------------------------
    Read/write the run-time registers
   ----------------------------------------------- */
/* Read/write the run-time registers menu options */
enum {
    MENU_RW_REGS_READ_ALL = 1,
    MENU_RW_REGS_READ_REG,
    MENU_RW_REGS_WRITE_REG,
    MENU_RW_REGS_EXIT = DIAG_EXIT_MENU,
};

/* Display read/write run-time registers menu */
static void MenuReadWriteRegs(WDC_DEVICE_HANDLE hDev)
{
    DWORD option;
    
    if (!PCI9056_REGS_NUM)
    {
        printf("There are currently no pre-defined run-time registers\n");
        return;
    }
  
    do {
        /* Display pre-defined registers' information */
        printf("\n");
        printf("PCI9056 run-time registers:\n");
        printf("--------------------------\n");   
        WDC_DIAG_RegsInfoPrint(gpPCI9056_Regs, PCI9056_REGS_NUM, WDC_DIAG_REG_PRINT_ALL);

        printf("\n");
        printf("Read/write the PCI9056 run-time registers\n");
        printf("-----------------------------------------\n");
        printf("%d. Read all run-time registers defined for the device (see list above)\n",
            MENU_RW_REGS_READ_ALL);
        printf("%d. Read from a specific register\n", MENU_RW_REGS_READ_REG);
        printf("%d. Write to a specific register\n", MENU_RW_REGS_WRITE_REG);
        printf("%d. Exit menu\n", MENU_RW_REGS_EXIT);
        printf("\n");

        if (DIAG_INPUT_FAIL == DIAG_GetMenuOption(&option,
            MENU_RW_REGS_WRITE_REG))
        {
            continue;
        }

        switch (option)
        {
        case MENU_RW_REGS_EXIT: /* Exit menu */
            break;
        case MENU_RW_REGS_READ_ALL:
            WDC_DIAG_ReadRegsAll(hDev, gpPCI9056_Regs, PCI9056_REGS_NUM, FALSE);
            break;
        case MENU_RW_REGS_READ_REG:  /* Read from a register */
            WDC_DIAG_ReadWriteReg(hDev, gpPCI9056_Regs, PCI9056_REGS_NUM, WDC_READ, FALSE);
            break;
        case MENU_RW_REGS_WRITE_REG: /* Write to a register */
            WDC_DIAG_ReadWriteReg(hDev, gpPCI9056_Regs, PCI9056_REGS_NUM, WDC_WRITE, FALSE);
            break;
        }
    } while (MENU_RW_REGS_EXIT != option);
}

/* -----------------------------------------------
    Interrupt handling
   ----------------------------------------------- */
/* Interrupts menu options */
enum {
    MENU_INT_ENABLE_DISABLE = 1,
    MENU_INT_EXIT = DIAG_EXIT_MENU,
};
#if 0
/* Enable/Disable interrupts menu */
static void MenuInterrupts(WDC_DEVICE_HANDLE hDev)
{
    DWORD option, dwIntOptions;
    BOOL fIntEnable, fIsMsi;

    dwIntOptions = WDC_GET_INT_OPTIONS(hDev);
    fIsMsi = WDC_INT_IS_MSI(dwIntOptions);
    if (dwIntOptions & INTERRUPT_LEVEL_SENSITIVE)
    {
        /* TODO: You can remove this message after you have modified the
           implementation of PCI9056_IntEnable() in pci9056_lib.c to 
           correctly acknowledge level-sensitive interrupts (see guidelines
           in PCI9056_IntEnable()) */
        printf("\n");
        printf("WARNING!!!\n");
        printf("----------\n");
        printf("Your hardware has level sensitive interrupts.\n");
        printf("Before enabling the interrupts, %s first modify the source "
           "code of PCI9056_IntEnable(), in the file pci9056_lib.c, to "
           "correctly acknowledge\n%s interrupts when they occur (as dictated by "
           "the hardware's specifications)\n",
           fIsMsi ? "it's recommended that you" : "you must",
           fIsMsi ? "level sensitive" : "");    }

    do
    {
        fIntEnable = !PCI9056_IntIsEnabled(hDev);

        printf("\n");
        printf("Interrupts\n");
        printf("-----------\n");
        printf("%d. %s interrupts\n", MENU_INT_ENABLE_DISABLE,
            fIntEnable ? "Enable" : "Disable");
        printf("%d. Exit menu\n", MENU_INT_EXIT);
        printf("\n");

        if (DIAG_INPUT_FAIL == DIAG_GetMenuOption(&option,
            MENU_RW_ADDR_WRITE))
        {
            continue;
        }

        switch (option)
        {
        case MENU_INT_EXIT: /* Exit menu */
            break;
        case MENU_INT_ENABLE_DISABLE: /* Enable/disable interrupts */
            if (fIntEnable)
            {
                DWORD dwStatus = PCI9056_IntEnable(hDev, DiagIntHandler);

                if (WD_STATUS_SUCCESS == dwStatus)
                    printf("Interrupts enabled\n");
                else
                {
                    PCI9056_ERR("Failed enabling interrupts. Error 0x%lx - %s\n",
                       dwStatus, Stat2Str(dwStatus));
                }
            }
            else
            {
                if (WD_STATUS_SUCCESS == PCI9056_IntDisable(hDev))
                    printf("Interrupts disabled\n");
                else
                    PCI9056_ERR("Failed disabling interrupts: %s", PCI9056_GetLastErr());
            }
            break;
        }
    } while (MENU_INT_EXIT != option);
}
#endif
/* Diagnostics interrupt handler routine */
static void DiagIntHandler(WDC_DEVICE_HANDLE hDev, PCI9056_INT_RESULT *pIntResult)
{
    /* TODO: You can modify this function in order to implement your own
             diagnostics interrupt handler routine */
    UINT32 u32Data;
#ifndef BHT_A429_INTR_CLR
#define BHT_A429_INTR_CLR					0X0024
#endif
#ifndef BHT_A429_INTR_STATE
#define BHT_A429_INTR_STATE					0X0028
#endif

    WDC_ReadAddr32(hDev, 2, BHT_A429_INTR_STATE, &u32Data);
    if(u32Data)
    {
        u32Data = 0x1;
        WDC_WriteAddr32(hDev, 2, BHT_A429_INTR_CLR, &u32Data);
        u32Data = 1;
        WDC_WriteAddr32(hDev, 2, 0x30, &u32Data);
        

        int_count++;
        printf("int count = %d\n", int_count);

//        printf("Got interrupt number %ld\n", pIntResult->dwCounter);
//        printf("Interrupt Type: %s\n",
//            WDC_DIAG_IntTypeDescriptionGet(pIntResult->dwEnabledIntType));
//        if (WDC_INT_IS_MSI(pIntResult->dwEnabledIntType))
//            printf("Message Data: 0x%lx\n", pIntResult->dwLastMessage);
    }
}

/* ----------------------------------------------------
    Plug-and-play and power management events handling
   ---------------------------------------------------- */
/* Events menu options */
enum {
    MENU_EVENTS_REGISTER_UNREGISTER = 1,
    MENU_EVENTS_EXIT = DIAG_EXIT_MENU,
};

/* Register/unregister Plug-and-play and power management events */
static void MenuEvents(WDC_DEVICE_HANDLE hDev)
{
    DWORD option;
    BOOL fRegister;

    do
    {
        fRegister = !PCI9056_EventIsRegistered(hDev);
        
        printf("\n");
        printf("Plug-and-play and power management events\n");
        printf("------------------------------------------\n");
        printf("%d. %s events\n", MENU_EVENTS_REGISTER_UNREGISTER,
            fRegister ? "Register" : "Unregister");
        printf("%d. Exit menu\n", MENU_EVENTS_EXIT);
        printf("\n");
        
        if (DIAG_INPUT_FAIL == DIAG_GetMenuOption(&option,
            MENU_EVENTS_REGISTER_UNREGISTER))
        {
            continue;
        }

        switch (option)
        {
        case MENU_EVENTS_EXIT: /* Exit menu */
            break;
        case MENU_EVENTS_REGISTER_UNREGISTER: /* Register/unregister events */
            if (fRegister)
            {
                if (WD_STATUS_SUCCESS == PCI9056_EventRegister(hDev, DiagEventHandler))
                    printf("Events registered\n");
                else
                    PCI9056_ERR("Failed to register events. Last error:\n%s", PCI9056_GetLastErr());
            }
            else
            {
                if (WD_STATUS_SUCCESS == PCI9056_EventUnregister(hDev))
                    printf("Events unregistered\n");
                else
                    PCI9056_ERR("Failed to unregister events. Last Error:\n%s", PCI9056_GetLastErr());
            }
            break;
        }
    } while (MENU_EVENTS_EXIT != option);
}

/* Plug-and-play and power management events handler routine */
static void DiagEventHandler(WDC_DEVICE_HANDLE hDev, DWORD dwAction)
{
    /* TODO: You can modify this function in order to implement your own
             diagnostics events handler routine */

    printf("\nReceived event notification (device handle 0x%p): ", hDev);
    switch (dwAction)
    {
    case WD_INSERT:
        printf("WD_INSERT\n");
        break;
    case WD_REMOVE:
        printf("WD_REMOVE\n");
        break;
    case WD_POWER_CHANGED_D0:
        printf("WD_POWER_CHANGED_D0\n");
        break;
    case WD_POWER_CHANGED_D1:
        printf("WD_POWER_CHANGED_D1\n");
        break;
    case WD_POWER_CHANGED_D2:
        printf("WD_POWER_CHANGED_D2\n");
        break;
    case WD_POWER_CHANGED_D3:
        printf("WD_POWER_CHANGED_D3\n");
        break;
    case WD_POWER_SYSTEM_WORKING:
        printf("WD_POWER_SYSTEM_WORKING\n");
        break;
    case WD_POWER_SYSTEM_SLEEPING1:
        printf("WD_POWER_SYSTEM_SLEEPING1\n");
        break;
    case WD_POWER_SYSTEM_SLEEPING2:
        printf("WD_POWER_SYSTEM_SLEEPING2\n");
        break;
    case WD_POWER_SYSTEM_SLEEPING3:
        printf("WD_POWER_SYSTEM_SLEEPING3\n");
        break;
    case WD_POWER_SYSTEM_HIBERNATE:
        printf("WD_POWER_SYSTEM_HIBERNATE\n");
        break;
    case WD_POWER_SYSTEM_SHUTDOWN:
        printf("WD_POWER_SYSTEM_SHUTDOWN\n");
        break;
    default:
        printf("0x%lx\n", dwAction);
        break;
    }
}



/* bht_L0_windows.c - Layer 0 implement in windows*/

/*
 * Copyright (c) 2017-2023 Bin Hong Tech, Inc.
 *
 * The right to copy, distribute, modify or otherwise make use
 * of this software may be licensed only pursuant to the terms
 * of an applicable Wind River license agreement.
 */

/*
modification history
--------------------
01a,17may17,cx_  add support in windows
*/
#ifdef WINDOWS_OPS

#include <windows.h>
#include <wdc_lib.h>
#include <wdc_defs.h>

#include <bht_L0.h>
#include <bht_L0_device.h>
#include <bht_L0_config.h>
#include <stdio.h>
#define DEBUG

#ifdef DEBUG
#define DEBUG_PRINTF(x, ...)\
do\
{\
	va_list ap; \
	va_start(ap, x); \
	(void)printf(x, ap);\
	va_end(ap);\
}while (0);
#else
#define DEBUG_PRINTF(x, ...)
#endif
#define LICENSE_10_2 "6C3CC2CFE89E7AD0424A070D434A6F6DC4950E31.hwacreate"

/* windows pci device control block */
typedef struct
{
    bht_L0_device_t *device;
    WD_PCI_CARD_INFO card_info;
    WDC_DEVICE_HANDLE wd_handle;
    bht_L0_sem pci_sem;
}win_pci_device_cb_t;

static bht_L0_u32 devices_cb[16][256][16] = {0}; /* Backplane type, board type, board */

static BOOL DeviceValidate(const PWDC_DEVICE pDev)
{
    DWORD i, dwNumAddrSpaces = pDev->dwNumAddrSpaces;

    /* NOTE: You can modify the implementation of this function in order to
             verify that the device has the resources you expect to find */
    
    /* Verify that the device has at least one active address space */
    for (i = 0; i < dwNumAddrSpaces; i++)
    {
        if (WDC_AddrSpaceIsActive(pDev, i))
            return TRUE;
    }
    
    /* In this sample we accept the device even if it doesn't have any
     * address spaces */ 
    printf("Device does not have any active memory or I/O address spaces\n");
    return TRUE;
}

static void pci_card_info_dump(WD_PCI_CARD_INFO * card_info)
{
    bht_L0_u32 index;
    
    if(NULL == card_info)
        return;
    
    printf("dwBus      : %d\n",card_info->pciSlot.dwBus);
    printf("dwSlot     : %d\n",card_info->pciSlot.dwSlot);
    printf("dwFunction : %d\n",card_info->pciSlot.dwFunction);
    printf("dwItems : %d\n",card_info->Card.dwItems);
    
    for(index = 0; index < card_info->Card.dwItems; index++)
    {
        printf("item type    : %d\n",card_info->Card.Item[index].item);
        printf("fNotSharable : %d\n",card_info->Card.Item[index].fNotSharable);
        printf("dwOptions    : 0x%08x\n",card_info->Card.Item[index].dwOptions);
        switch(card_info->Card.Item[index].item)
        {
            case ITEM_MEMORY:
                printf("dwPhysicalAddr : 0x%08x\n", card_info->Card.Item[index].I.Mem.dwPhysicalAddr);
                printf("dwBytes : 0x%08x\n", card_info->Card.Item[index].I.Mem.dwBytes);
                printf("dwUserDirectAddr : 0x%08x\n", card_info->Card.Item[index].I.Mem.dwUserDirectAddr);
                printf("dwCpuPhysicalAddr : 0x%08x\n", card_info->Card.Item[index].I.Mem.dwCpuPhysicalAddr);
                printf("dwBar : 0x%08x\n", card_info->Card.Item[index].I.Mem.dwBar);
                break;
            case ITEM_IO:
                printf("dwAddr : 0x%08x\n", card_info->Card.Item[index].I.IO.dwAddr);
                printf("dwBytes : 0x%08x\n", card_info->Card.Item[index].I.IO.dwBytes);
                printf("dwBar : 0x%08x\n", card_info->Card.Item[index].I.IO.dwBar);
                break;
            case ITEM_INTERRUPT:
                printf("dwInterrupt : 0x%08x\n", card_info->Card.Item[index].I.Int.dwInterrupt);
                printf("dwOptions : 0x%08x\n", card_info->Card.Item[index].I.Int.dwOptions);
                printf("hInterrupt : 0x%08x\n", card_info->Card.Item[index].I.Int.hInterrupt);
                break;
            default:
                printf("UNKNOWN ITEM TYPE -> %d\n", card_info->Card.Item[index].item);
                break;
        }
    }
}

bht_L0_u32 
bht_L0_init(void)
{
    static bht_L0_u32 is_wd_lib_inited = 0;
    DWORD dwStatus = WD_STATUS_SUCCESS; 

    if(is_wd_lib_inited)
        return BHT_SUCCESS;
    
    //打开Windriver驱动.
    dwStatus = WDC_DriverOpen(WDC_DRV_OPEN_DEFAULT, LICENSE_10_2);
    if (WD_STATUS_SUCCESS != dwStatus)
    {
    	WDC_Err("Error:%d - Failed to open driver.\n", dwStatus); 
    	return BHT_ERR_WINDRIVER_INIT_FAIL;
    }

    //设置调试选项
    dwStatus = WDC_SetDebugOptions(WDC_DBG_DEFAULT, NULL);
    if (WD_STATUS_SUCCESS != dwStatus)
    {
    	WDC_Err("Error:%d - Failed to set debug option.\n", dwStatus);  
    	return BHT_ERR_WINDRIVER_INIT_FAIL;
    }

#if defined(WD_DRIVER_NAME_CHANGE)
    /* Set the driver name */
    if (!WD_DriverName(TEST5064_DEFAULT_DRIVER_NAME))
    {
    	WDC_Err("Failed to set the driver name for WDC library.\n");
    	return BHT_ERR_WINDRIVER_INIT_FAIL;
    }
#endif

    is_wd_lib_inited = 1;

    return BHT_SUCCESS;
}
/* Function : bht_L0_msleep
 * Description : ms sleep function
 * @param msdelay, how manny ms do you want to delay
 * @return void
 */
void bht_L0_msleep(bht_L0_u32 msdelay)
{
//    WDC_Sleep(1000 * msdelay, WDC_SLEEP_BUSY);//此处文档上说低于17000，不起作用
    Sleep(msdelay);
}

bht_L0_u32 
bht_L0_device_scan(bht_L0_dtype_e dtype)
{
    bht_L0_u32 result = BHT_SUCCESS;
    bht_L0_itype_e itype;
    bht_L0_u16 device_id;
    WDC_PCI_SCAN_RESULT scan_result;

    if(dtype >= BHT_L0_DEVICE_TYPE_MAX)
		return 0;

    itype = bht_L0_dtypeinfo_items[dtype].itype;
    
    switch(itype)
    {
        case BHT_L0_INTERFACE_TYPE_PCI:
            /* device id*/
            if((BHT_L0_DEVICE_TYPE_ARINC429 == dtype))
            {
                device_id = BHT_PCI_DEVICE_ID_PMC429;
            }
			else
			{
				DEBUG_PRINTF("interface type not support\n");
				return 0;
			}
            /* scan */
			if ((WD_STATUS_SUCCESS != WDC_PciScanDevices(BHT_PCI_VENDOR_ID, device_id, &scan_result))
				|| (scan_result.dwNumDevices < 0))
			{
				DEBUG_PRINTF("WDC_PciScanDevices err\n");
				return 0;
			}

            return scan_result.dwNumDevices;
        default:
			return 0;
    }
}

/* Function : bht_L0_map_memory
 * Description : This function maps the requested amount of memory and stores the memory 
                 pointer internally for use with the memory read/write functions.
 * @param msdelay, how manny ms do you want to delay
 * @return void
 */
bht_L0_u32 
bht_L0_map_memory(bht_L0_device_t *device, 
        void * arg)
{
    bht_L0_u32 result = BHT_SUCCESS;
    const bht_L0_itype_e itype = device->itype;
    const bht_L0_dtype_e dtype = device->dtype;
    const bht_L0_u32 device_no = device->device_no;

    switch(itype)
    {
        case BHT_L0_INTERFACE_TYPE_PCI:
            do
            {
                DWORD pci_vendor_id = BHT_PCI_VENDOR_ID;
                DWORD pci_device_id = 0;
                WDC_PCI_SCAN_RESULT scan_result;
				WD_PCI_CARD_INFO card_info;
                WDC_DEVICE_HANDLE hDev;
                DWORD dwStatus;
                WD_PCI_CARD_INFO deviceInfo;
                

                if(NULL != device->lld_hand)
                    break;

                BZERO(card_info);

                /* device id*/
                if(BHT_L0_DEVICE_TYPE_ARINC429 == dtype)
                {
                    pci_device_id = BHT_PCI_DEVICE_ID_PMC429;
                }
                else
                    return BHT_ERR_UNSUPPORTED_DEVICE_TYPE;

                hDev = DeviceFindAndOpen(pci_vendor_id, pci_device_id);
                if(NULL == hDev)
                    result = BHT_ERR_CANT_OPEN_DEV;
                else
                    device->lld_hand = (void*)hDev;
                    
#if 0
                /* scan */
                if((WD_STATUS_SUCCESS != WDC_PciScanDevices(BHT_PCI_VENDOR_ID, pci_device_id, &scan_result))
                    || (scan_result.dwNumDevices < 0))
                    return BHT_ERR_LOW_LEVEL_DRIVER_ERR;
                
                if(scan_result.dwNumDevices < (device_no + 1))
                    return BHT_ERR_NO_DEVICE;

                card_info.pciSlot.dwBus = scan_result.deviceSlot[device_no].dwBus;
                card_info.pciSlot.dwFunction = scan_result.deviceSlot[device_no].dwFunction;
                card_info.pciSlot.dwSlot = scan_result.deviceSlot[device_no].dwSlot;
                
                if(WD_STATUS_SUCCESS != WDC_PciGetDeviceInfo(&card_info))
                    return BHT_ERR_NO_DEVICE;
                
                if(WD_STATUS_SUCCESS != WDC_PciDeviceOpen((WDC_DEVICE_HANDLE*)&device->lld_hand, \
                    &card_info, NULL, NULL, NULL, NULL))
                    return BHT_ERR_CANT_OPEN_DEV;

                if (!DeviceValidate((PWDC_DEVICE)device->lld_hand))
                {
                    DEBUG_PRINTF("Device is not valid\n");
                    WDC_PciDeviceClose((WDC_DEVICE_HANDLE)device->lld_hand);
                    return BHT_ERR_CANT_OPEN_DEV;
                }
#endif
            }while(0); 
            break;
        default:
            result = BHT_ERR_UNSUPPORTED_DTYPE;
    }

    return result;
}

bht_L0_u32 bht_L0_unmap_memory(bht_L0_device_t *device)
{
    bht_L0_u32 result = BHT_SUCCESS;	

    switch(device->itype)
    {
        case BHT_L0_INTERFACE_TYPE_PCI:            
            if(NULL != device->lld_hand)
            {
                if(WD_STATUS_SUCCESS != WDC_PciDeviceClose((WDC_DEVICE_HANDLE )device->lld_hand))
                    result = BHT_ERR_DEVICE_CLOSE_FAIL;    
                else
                    device->lld_hand = NULL;
            }
            break;
        default:
            result = BHT_ERR_UNSUPPORTED_DTYPE;
    }

    return result;
}

bht_L0_u32 
bht_L0_read_mem32(bht_L0_device_t *device, 
        bht_L0_u32 offset, 
        bht_L0_u32 *data, 
        bht_L0_u32 count)
{
    bht_L0_u32 result = BHT_SUCCESS;	
    bht_L0_u32 idx;
    bht_L0_itype_e itype = device->itype;

    switch(itype)
    {
        case BHT_L0_INTERFACE_TYPE_PCI:            
            if(NULL != device->lld_hand)
            {
                idx = 0;
//                bht_L0_sem_take(pci_device_cb->pci_sem, BHT_WAITFOREVER);
                while(count != idx)
                {
                    if(WD_STATUS_SUCCESS != WDC_ReadAddr32((WDC_DEVICE_HANDLE)device->lld_hand, 2, \
                        (offset + 4 * idx), &data[idx]))
                    {
                        result = BHT_ERR_DRIVER_READ_FAIL;
                        break;
                    }
                    idx++;
                }
//                bht_L0_sem_give(pci_device_cb->pci_sem);
            }
            else
                result = BHT_ERR_DEV_NOT_INITED;
            break;
        default:
            result = BHT_ERR_UNSUPPORTED_DTYPE;
    }

    return result;
}

bht_L0_u32 bht_L0_read_mem32_dma(bht_L0_device_t *device, bht_L0_u32 offset, bht_L0_u32 *data, bht_L0_u32 count)
{
    return BHT_FAILURE;
}

bht_L0_u32 bht_L0_read_mem16(bht_L0_device_t *device, bht_L0_u32 offset, bht_L0_u16 *data, bht_L0_u32 count)
{
    return BHT_FAILURE;
}

bht_L0_u32 bht_L0_write_mem16(bht_L0_device_t *device, bht_L0_u32 offset, bht_L0_u16 *data, bht_L0_u32 count)
{
    return BHT_FAILURE;
}

bht_L0_u32 
bht_L0_write_mem32(bht_L0_device_t *device, 
        bht_L0_u32 offset, 
        bht_L0_u32 *data, 
        bht_L0_u32 count)
{
    bht_L0_u32 result = BHT_SUCCESS;	
    bht_L0_u32 idx;
    bht_L0_itype_e itype = device->itype;

    switch(itype)
    {
        case BHT_L0_INTERFACE_TYPE_PCI:            
            if(NULL != device->lld_hand)
            {
                idx = 0;
//                bht_L0_sem_take(pci_device_cb->pci_sem, BHT_WAITFOREVER);
                while(count != idx)
                {
                    if(WD_STATUS_SUCCESS != WDC_WriteAddr32((WDC_DEVICE_HANDLE)device->lld_hand, 2, \
                        (offset + 4 * idx), data[idx]))
                    {
                        result = BHT_ERR_DRIVER_WRITE_FAIL;
                        break;
                    }
                    idx++;
                }
//                bht_L0_sem_give(pci_device_cb->pci_sem);
            }
            else
                result = BHT_ERR_DEV_NOT_INITED;
            break;
        default:
            result = BHT_ERR_UNSUPPORTED_DTYPE;
    }

    return result;
}

bht_L0_u32 
bht_L0_read_setupmem32(bht_L0_device_t *device, 
        bht_L0_u32 offset, 
        bht_L0_u32 *data, 
        bht_L0_u32 count)
{
    bht_L0_u32 result = BHT_SUCCESS;	
    bht_L0_u32 idx;
    bht_L0_itype_e itype = device->itype;
    
    switch(itype)
    {
        case BHT_L0_INTERFACE_TYPE_PCI:            
            if(NULL != device->lld_hand)
            {
                idx = 0;
//                bht_L0_sem_take(pci_device_cb->pci_sem, BHT_WAITFOREVER);
                while(count != idx)
                {
                    if(WD_STATUS_SUCCESS != WDC_ReadAddr32((WDC_DEVICE_HANDLE)device->lld_hand,\
                        0, (offset + 4 * idx), &data[idx]))
                    {
                        result = BHT_ERR_DRIVER_READ_FAIL;
                        break;
                    }
                    idx++;
                }
//                bht_L0_sem_give(pci_device_cb->pci_sem);
            }
            else
                result = BHT_ERR_DEV_NOT_INITED;
            break;
        default:
            result = BHT_ERR_UNSUPPORTED_DTYPE;
    }

	return result;
}

bht_L0_u32 
bht_L0_write_setupmem32(bht_L0_device_t *device, 
        bht_L0_u32 offset, 
        bht_L0_u32 *data, 
        bht_L0_u32 count)
{
    bht_L0_u32 result = BHT_SUCCESS;	
    bht_L0_u32 idx;
    bht_L0_itype_e itype = device->itype;
    
    switch(itype)
    {
        case BHT_L0_INTERFACE_TYPE_PCI:            
            if(NULL != device->lld_hand)
            {
                idx = 0;
//                bht_L0_sem_take(pci_device_cb->pci_sem, BHT_WAITFOREVER);
                while(count != idx)
                {
                    if(WD_STATUS_SUCCESS != WDC_WriteAddr32((WDC_DEVICE_HANDLE)device->lld_hand, \
                        0, (offset + 4 * idx), data[idx]))
                    {
                        result = BHT_ERR_DRIVER_WRITE_FAIL;
                        break;
                    }
                    idx++;
                }
//                bht_L0_sem_give(pci_device_cb->pci_sem);
            }
            else
                result = BHT_ERR_DEV_NOT_INITED;
            break;
        default:
            result = BHT_ERR_UNSUPPORTED_DTYPE;
    }

	return result;
}

bht_L0_u32 
bht_L0_read_setupmem16(bht_L0_device_t *device, 
        bht_L0_u32 offset, 
        bht_L0_u16 *data, 
        bht_L0_u32 count)
{
    bht_L0_u32 result = BHT_SUCCESS;	
    bht_L0_u32 idx;
    bht_L0_itype_e itype = device->itype;

    switch(itype)
    {
        case BHT_L0_INTERFACE_TYPE_PCI:            
            if(NULL != device->lld_hand)
            {
                idx = 0;
//                bht_L0_sem_take(pci_device_cb->pci_sem, BHT_WAITFOREVER);
                while(count != idx)
                {
                    if(WD_STATUS_SUCCESS != WDC_ReadAddr16((WDC_DEVICE_HANDLE )device->lld_hand, 0,\
                        (offset + 2 * idx), &data[idx]))
                    {
                        result = BHT_ERR_DRIVER_READ_FAIL;
                        break;
                    }
                    idx++;
                }
//                bht_L0_sem_give(pci_device_cb->pci_sem);
            }
            else
                result = BHT_ERR_DEV_NOT_INITED;
            break;
        default:
            result = BHT_ERR_UNSUPPORTED_DTYPE;
    }

	return result;
}

bht_L0_u32 
bht_L0_write_setupmem16(bht_L0_device_t *device, 
        bht_L0_u32 offset, 
        bht_L0_u16 *data, 
        bht_L0_u32 count)
{
    bht_L0_u32 result = BHT_SUCCESS;	
    bht_L0_u32 idx;
    bht_L0_itype_e itype = device->itype;

    switch(itype)
    {
        case BHT_L0_INTERFACE_TYPE_PCI:            
            if(NULL != device->lld_hand)
            {
                idx = 0;
//                bht_L0_sem_take(pci_device_cb->pci_sem, BHT_WAITFOREVER);
                while(count != idx)
                {
                    if(WD_STATUS_SUCCESS != WDC_WriteAddr16((WDC_DEVICE_HANDLE)device->lld_hand, 0,\
                        (offset + 2 * idx), data[idx]))
                    {
                        result = BHT_ERR_DRIVER_WRITE_FAIL;
                        break;
                    }
                    idx++;
                }
//                bht_L0_sem_give(pci_device_cb->pci_sem);
            }
            else
                result = BHT_ERR_DEV_NOT_INITED;
            break;
        default:
            result = BHT_ERR_UNSUPPORTED_DTYPE;
    }

	return result;
}

bht_L0_u32 
bht_L0_attach_inthandler(bht_L0_device_t *device, 
        bht_L0_u32 chan_regoffset, 
        BHT_L0_USER_ISRFUNC isr, 
        void * arg)
{
    DWORD ret;
    bht_L0_u32 result = BHT_SUCCESS;	
    bht_L0_itype_e itype = device->itype;    

    switch(itype)
    {
        case BHT_L0_INTERFACE_TYPE_PCI:            
            if(NULL != device->lld_hand)
            {
            
//                WD_TRANSFER*pTrans = (WD_TRANSFER*) calloc(3, sizeof(WD_TRANSFER));
//                WDC_DEVICE *dev = (WDC_DEVICE *)pci_device_cb->wd_handle;
#ifndef BHT_A429_INTR_CLR
#define BHT_A429_INTR_CLR					0X0024
#endif
#ifndef BHT_A429_INTR_STATE
#define BHT_A429_INTR_STATE					0X0028
#endif
#if 1
//                (pTrans)->dwPort = (dev->pAddrDesc+2)->kptAddr + BHT_A429_INTR_STATE;
//                (pTrans)->cmdTrans = RM_DWORD;
//                (pTrans)->cmdTrans = WDC_ADDR_IS_MEM(dev->pAddrDesc+2) ? RM_DWORD : RP_DWORD;
//                
//                (pTrans+1)->cmdTrans = CMD_MASK;
//                (pTrans+1)->Data.Dword = BIT4;
//                
//                (pTrans+2)->dwPort = (dev->pAddrDesc+2)->kptAddr + BHT_A429_INTR_CLR;
//                (pTrans+2)->cmdTrans = WM_DWORD;
//                (pTrans+2)->cmdTrans = WDC_ADDR_IS_MEM(dev->pAddrDesc+2) ? WM_DWORD : WP_DWORD;

//                (pTrans+2)->Data.Dword = BIT0;
                
                DWORD dwStatus = PCI9056_IntEnable(device->lld_hand, DiagIntHandler);

                if (WD_STATUS_SUCCESS == dwStatus)
                    printf("Interrupts enabled\n");
                else
                {
                    PCI9056_ERR("Failed enabling interrupts. Error 0x%lx - %s\n",
                       dwStatus, Stat2Str(dwStatus));
                }
                
//				if(WD_STATUS_SUCCESS != (ret = WDC_IntEnable((WDC_DEVICE_HANDLE)device->lld_hand, \
//                    NULL, 0, INTERRUPT_CMD_COPY, (INT_HANDLER)isr, (PVOID)arg, WDC_IS_KP((WDC_DEVICE_HANDLE)device->lld_hand))))
//                {
//                    printf("func[%s] line[%d] ret = %d\n", __FUNCTION__, __LINE__, ret);
//                    result = BHT_ERR_DRIVER_INT_ATTACH_FAIL;
//                }
#else
                if(WD_STATUS_SUCCESS != WDC_IntEnable(pci_device_cb->wd_handle, NULL, 0, 0, \
                    (INT_HANDLER)isr, (PVOID)arg, WDC_IS_KP(pci_device_cb->wd_handle)))
                    result = BHT_ERR_DRIVER_INT_ATTACH_FAIL;
#endif
            }
            else
                result = BHT_ERR_DEV_NOT_INITED;
            break;
        default:
            result = BHT_ERR_UNSUPPORTED_DTYPE;
    }
    
    return result;
}

bht_L0_u32 bht_L0_detach_inthandler(bht_L0_device_t *device)
{
    bht_L0_u32 result = BHT_SUCCESS;	
    bht_L0_itype_e itype = device->itype;
    PWDC_DEVICE pDev = (PWDC_DEVICE)device->lld_hand;
    
    switch(itype)
    {
        case BHT_L0_INTERFACE_TYPE_PCI:            
            if(NULL != device->lld_hand)
            {
                if(!WDC_IntIsEnabled((WDC_DEVICE_HANDLE)device->lld_hand))
            	{
            		return BHT_ERR_DRIVER_INT_DETACH_FAIL;
            	}

                if (WD_STATUS_SUCCESS == PCI9056_IntDisable(device->lld_hand))
                    printf("Interrupts disabled\n");
                else
                    PCI9056_ERR("Failed disabling interrupts: %s", PCI9056_GetLastErr());
            }
            else
                result = BHT_ERR_DEV_NOT_INITED;
            break;
        default:
            result = BHT_ERR_UNSUPPORTED_DTYPE;
    }
    
    return result;
}

bht_L0_sem
bht_L0_semc_create(bht_L0_u32 initial_cnt, bht_L0_u32 max_cnt)
{
    HANDLE semc;

    semc = CreateSemaphore(NULL, initial_cnt, max_cnt, NULL);

    return (bht_L0_sem)semc;
}

bht_L0_sem
bht_L0_semm_create(void)
{
    HANDLE semm;

    semm = CreateSemaphore(NULL, 1, 1, NULL);

    return (bht_L0_sem)semm;
}

bht_L0_u32 
bht_L0_sem_take(bht_L0_sem sem, bht_L0_s32 timeout_ms)
{
    DWORD ret;
    DWORD wtimeout;
    HANDLE wsem = (HANDLE)sem;

    if(BHT_WAITFOREVER == timeout_ms)
        wtimeout = INFINITE;
    else
        wtimeout = (DWORD)timeout_ms;
        
    ret = WaitForSingleObject(wsem, wtimeout);

    if(ret == 0)
        return BHT_SUCCESS;
    else
        return BHT_FAILURE;
}

bht_L0_u32 
bht_L0_sem_give(bht_L0_sem sem)
{
    DWORD ret;
    HANDLE wsem = (HANDLE)sem;

    ret = (DWORD)ReleaseSemaphore(wsem, 1, NULL);

    if(BHT_TRUE == ret)
        return BHT_SUCCESS;
    else
        return BHT_FAILURE;
}

bht_L0_u32
bht_L0_sem_destroy(bht_L0_sem sem)
{
    DWORD ret;

    ret = CloseHandle((HANDLE)sem);
    if(BHT_TRUE == ret)
        return BHT_SUCCESS;
    else
        return BHT_FAILURE;
}

#endif

